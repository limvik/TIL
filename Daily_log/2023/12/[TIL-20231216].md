# TIL-20231216

## 12월 할 일

1. 원티드 이력서 개선 및 지원(20/20) ~ 12/17까지
2. 운영체제 강의 완료(14/18)

## 이번주 목표

1. 원티드 지원 20개 채우기 - 완
2. Connection Pool 부하 테스트 및 블로그 기록 - 완
3. Spring Academy, OAuth2 구현 실습

## 오늘 할 일

- 오전(~13:00)
  - 개인 일정
- 오후(~18:00)
  - Flashcards 복습
  - 강의 듣기
  - 독서
- 야간
  - 독서
  - 운동 1시간 상체 및 유산소

## 내일 할 일

- 오전(~13:00)
  - Flashcards 복습
  - 강의 듣기
- 오후(~18:00)
  - 연습용 코테 응시
  - 독서
- 야간
  - 신규 프로젝트 조사
  - 운동 30분 이내 하체

## 공부한 것

### 강의 듣기

#### [Coursera] AWS Cloud Technical Essentials(3.1/4 진행중)

- 수강 목적: 클라우드 기반 기술 및 AWS 사용법 학습
- [4주차: Monitoring on AWS]
  - IT 리소스와 시스템에 대한 의사 결정이나 질문에 대한 답을 얻기 위해 데이터를 수집, 분석, 사용하는 행위를 모니터링이라고 한다.
  - 모니터링을 통해 수집한 데이터를 metric이라 한다.
  - 애플리케이션에 장애가 발생했다는 사실을 end user가 알 때까지 기다리는 것은 좋지 않다. 모니터링을 통해 end user가 문제를 인지하기 전에 문제를 해결해야 한다.
  - Amazon CloudWatch는 여러 리소스들의 흩어져있는 모니터링 데이터를 한곳에서 관리할 수 있도록 해주는 서비스

#### [KMOOC] 운영체제의 기초

- 수강 목적: CS 공부
- File System - File Structures
  - OS 관점에서 File System은 Storage Device 위의 Formatted Volume 이라 할 수 있다.
  - Disk Block을 잘 관리하는 것이 File System의 역할
  - Storage Device 또는 Main Memory에 있는 다양한 File과 관련된 Data Structure 들도 File System의 일부
  - File System은 100% 소프트웨어로 구현
  - HDD와 SSD는 속성이 매우 달라 서로 다른 Device Driver를 사용한다. SSD의 Device Driver는 FTL(Flash Translation Layer) 라고 부른다.
  - 대부분의 I/O Operation은 Buffer Cache(Linux 의 경우 Page Cache)에서 끝난다. Cache miss가 난 경우에만 I/O Scheduler를 통해 Storage에 접근한다.
  - File System의 경우 굉장히 다양하여 이를 통합하는 VFS(Virtual File System) 이 존재한다.
  - File System 설계의 가장 큰 목표는 Average Access Time을 최소화하는 것이다.

#### Spring Security - Securing a REST API with OAuth 2.0

- Authorization은 Request-Level Authorization과 Method-Level Authorization으로 나눌 수 있다.
- Method-Level 은 HTTP 외의 프로토콜을 사용 시에도 제어가 가능하다는 장점이 있다. 다음과 같이 Service Layer의 method에도 적용 가능하다.

```java
@Service
public class CustomerService {
    @PreAuthorize("hasRole(‘CUSTOMER_SERVICE')")
    public Customer cancelAccount(UUID id);
}
```

- Request-Level 은 js, css 등의 static file 에 대한 접근 권한 관리나, /admin/** 처럼 여러 경로에 대한 접근 권한 관리를 손쉽게 할 수 있다는 장점이 있다.
- Method-Level 은 @PreAuthorize 와 @PostAuthorize annotation을 이용하여 method 요청 전/후로 보안을 강화할 수 있다.
- 문서에 더 다양한 사용법이 있어서 문서 보는게 좋을 듯([링크](https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html))

```java
@GetMapping("/cashcards")
@PreAuthorize("hasAuthority(‘cashcard:read')")
public ResponseEntity<Iterable<CashCard>> findAll(@CurrentOwner String owner) {
    // ...
}

@GetMapping("/cashcard/{id}")
@PostAuthorize("returnObject.body.owner == authentication.name")
public ResponseEntity<CashCard> findById(@RequestParam("id") String id) {
    // ...
}
```

- Method-Level이랑 Request-Level 같이 설정해 봤는데, Request-Level이 우선해서 적용된다.
- JWT 의 `scp` claim은 scope를 의미
- Request-Level Authorization 설정 시 항상 마지막은 .anyRequest().autehnticated()로 마무리 해서, 잊어버리고 권한 설정을 안하더라도 최소 권한의 원칙을 지킬 수 있게 만든다.

```java
@Bean
SecurityFilterChain appSecurity(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests((authorize) -> authorize
            // ...
            .anyRequest().authenticated()
        )
        // ...
}
```

### 잘한점, 개선점, 배운점
